<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zbsThink&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-19T01:24:06.196Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zbsThink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Github的一些简易使用</title>
    <link href="http://yoursite.com/2018/11/12/learnGithub/"/>
    <id>http://yoursite.com/2018/11/12/learnGithub/</id>
    <published>2018-11-12T02:39:13.000Z</published>
    <updated>2018-11-19T01:24:06.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github简介"><a href="#Github简介" class="headerlink" title="Github简介"></a>Github简介</h3><p>Github是用于版本控制和协作的代码托管平台，它可以让您和其他人在任何地方协同工作，Gihub可以托管各种Git版本库，并提供一个web界面，但与其他像SourceForge或Google Code这样的服务不同，Github的独特卖点在于从另外一个项目进行分支的简易性<br><a id="more"></a></p><h4 id="如何为一个项目贡献代码？"><a href="#如何为一个项目贡献代码？" class="headerlink" title="如何为一个项目贡献代码？"></a>如何为一个项目贡献代码？</h4><p>首先点击项目的<code>fork</code>按钮，然后将代码检出并修改加入到刚才分出的代码库中，最后通过内建的<code>pull request</code>机制向项目负责人申请代码合并</p><h4 id="本地更新与远程更新的纠葛"><a href="#本地更新与远程更新的纠葛" class="headerlink" title="本地更新与远程更新的纠葛"></a>本地更新与远程更新的纠葛</h4><ol><li><p>远程库更新-&gt;本地更新</p><ul><li>第一种方法：<code>get pull origin master</code>(这句话的意思是拉取origin远程仓库master分支并和本地的分支合并，同时更新本地分支)<br>语法： <code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>(主机和仓库意思一样)意思是拉取远程仓库的远程分支并与本地分支进行合并，同时更新本地分支<br>例如：<code>git pull origin next:master</code>拉取远程origin仓库的next分支与本地的master分支进行合并，同时更新本地的分支。<br>描述：将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch 后跟 git merge FETCH_HEAD的缩写，更准确的说是使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中，使用–rebase，他运行git rebase 而不是git merge<br>*第二种方法<br>首先查看远程分支:<code>git remote -v</code><br>第一步：<code>git fetch origin master:temp</code>抓取origin远程仓库的master分支并将其代码下载到本地的temp分支<br>第二步：<code>git diff temp</code>比较本地仓库分支与下载的保存在本地的temp分支确认无误后进行第三步<br>第三步：<code>git merge temp</code>将本地仓库分支与下载的temp合并<br>第四步（非必需）<code>git branch -d temp</code>也可以使用<code>git branch -D &lt;name&gt;</code>强制删除</li></ul></li><li><p>本地更新-&gt;远程库更新<br>这里的本地有两种一种是自己创建的本地仓库然后进行关联远程github仓库，然后在提交本地修改的文件或者添加文件到本地库，最后推送本地修改的文件到远程github仓库</p></li></ol><ul><li><p>第一种本地库（自己本地计算机上创建）<br>第一步：在github上创建一个仓库，并且记录下它的地址如<a href="https://www.exmple.com" target="_blank" rel="noopener">https://www.exmple.com</a><br>第二步：在自己电脑上创建一个文件夹如learnGithub，在里面添加文件如01.html<br>第三步：git操作</p><pre><code>第一步：`git init` (生成本地的git管理库)第二步：`git add .`(将文件添加git管理库中并且添加追踪。如果只想添加某个特定的文件，只需要将.换成特定的名称即可)第三步：`git commit -m &quot;注释&quot;`举例：`git commit -m &apos;first commit&apos;`(提交暂存区并添加注释-m后面的就是注释)第四步：`git remote add origin https://自己仓库的url地址`（remote：远程，origin:远程仓库名，整个语句就是关联origin远程库）第五步： `git push -u origin master`(添加-u表示默认，后买你就可以不加任何参数使用git push了如：`git push origin master`，整句话的意思是上传代码到github远程库)解释下`git push`命令git push命令用于将本地分支的更新推送到远程主机。它的格式与git pull命令相似格式:git push &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;第六步：进入github你所创建的仓库查看第七步：再次添加文件或者修改了使用`git push origin master`命令</code></pre><ul><li><p>第二种本地库(自己从github上克隆下载到本地，然后在本地进行文件修改或者增加文件然后推送到(push)远程分支即可)-多人协作（在dev分支上进行开发，master主分支只保存最新的成熟的版本）<br> 第一步：首先你要先从远程仓库下载完整内容使用如下命令<br> <code>git clone http地址或者ssl地址</code><br> 第二步：你可以在你clone的目录中的文件进行修改或者添加新文件到相关分支如添加到dev分支<br> <code>git checkout -b dev origin/dev</code>//创建远程origin的dev分支到本地，并切换到本地dev分支<br> 第三步：将最新的更改添加提交后，push到远程的orign/dev使用如下命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;注释语句&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p> 第四步：如果推送失败，这是因为远程分支比你的本地版本更新，需要先用<code>git pull</code>试图合并<br> 如果<code>git pull</code>失败，并提示<code>no tracking information</code>则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to=origin/dev dev</code>;如果<code>git pull &#39;成功了但是有冲突，那么就先解决冲突（删除相关语句或者重写相关语句）然后再</code>git commit -m ‘注释语句’<code>和</code>git push origin dev`多人协作就此完成</p></li></ul></li></ul><ol start="3"><li>多人协作远程库更新<br><strong>分支是一次处理不同版本的存储库的方法</strong><br><strong>默认情况下，我们的存储库有一个名为master的权威分支branch，该分支被认为是权威分支。</strong><br><strong>当你在分支机构上创建master分支时，我们正在制作该master时间点的副本或者快照，如果其他人创建了master分支并且做出更改时我们可以拉取请求（pull）和合并（merge）来更新master</strong><br><a href="https://www.cnblogs.com/wj-1314/p/9901763.html" target="_blank" rel="noopener">这里是关于Github中分支的学习</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Github简介&quot;&gt;&lt;a href=&quot;#Github简介&quot; class=&quot;headerlink&quot; title=&quot;Github简介&quot;&gt;&lt;/a&gt;Github简介&lt;/h3&gt;&lt;p&gt;Github是用于版本控制和协作的代码托管平台，它可以让您和其他人在任何地方协同工作，Gihub可以托管各种Git版本库，并提供一个web界面，但与其他像SourceForge或Google Code这样的服务不同，Github的独特卖点在于从另外一个项目进行分支的简易性&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>deepLearnGit</title>
    <link href="http://yoursite.com/2018/11/11/deepLearnGit/"/>
    <id>http://yoursite.com/2018/11/11/deepLearnGit/</id>
    <published>2018-11-11T14:56:07.000Z</published>
    <updated>2018-11-19T02:07:31.282Z</updated>
    
    <content type="html"><![CDATA[<p><em>这里是我做的关于git学习的笔记，记的也比较详细</em><br><a id="more"></a></p><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><ul><li><strong>Git是分布式版本控制系统</strong></li><li><strong>集中式VS分布式，SVN VS Git</strong><ol><li>SVN和Git的主要区别在于历史版本维护的位置</li><li>Git本地仓库包含代码库还有历史库，在本地环境开发就可以记录历史，而SVN的历史库存于中央仓库，每次对比于提交代码都必须连接到中央仓库才能进行</li><li><strong>这样的好处在于</strong><ul><li>自己可以在脱机的情况下查看开发的历史版本</li><li>多人开发时如果中央仓库Git仓库挂了，可以随时创建一个新的中央仓库然后就立刻恢复到了中央库<h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><p><code>git config</code>命令的<code>--global</code>参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><h4 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h4><p><code>git init</code></p><h4 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h4><p>包括两步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;decription&quot;</span><br></pre></td></tr></table></figure></p><p><code>git add</code>可以反复使用，添加多个文件，<code>git commit</code>可以一次性提交很多文件，<code>-m</code>后输入的是本次提交的说明，可以输入任意内容</p><h4 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h4><p><code>git status</code></p><h4 id="查看修改的内容"><a href="#查看修改的内容" class="headerlink" title="查看修改的内容"></a>查看修改的内容</h4><p>总共有三个分别是：<br><code>git diff</code></p><p><code>git diff --cached</code></p><p><code>git diff HEAD -- &lt;file&gt;</code></p><ul><li><code>git diff</code>可以查看工作区（work dict）和暂存区（stage）的区别</li><li><code>git diff --cached</code> 可以查看暂存区（stage）和分支(master)的区别</li><li><code>git diff HEAD -- &lt;file&gt;</code>可以查看工作区和版本库里面最新版本的区别<h2 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h2>工作区：在电脑里面能看到的目录<br>版本库：在工作区又一个隐藏目录<code>.git</code>，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD<br><img src="/2018/11/11/deepLearnGit/version.jpg" alt="工作区，暂存区和版本库"><br>进一步解释一些命令：<ul><li><code>git add</code>实际上是把文件添加到暂存区</li><li><code>git commit</code>实际上是把暂存区的所有内容提交到当前分支<h2 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h2><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><h3 id="时光穿梭机-撤销修改"><a href="#时光穿梭机-撤销修改" class="headerlink" title="时光穿梭机-撤销修改"></a>时光穿梭机-撤销修改</h3>前提是你的文件以前使用过<code>git add &lt;file&gt;</code><h4 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h4><code>git checkout -- &lt;file&gt;</code><br>该命令是指文件在工作区的修改全部撤销，这里有两种情况:</li></ul><ol><li>一种是flie自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种时候file已经添加到暂存区，又做了修改，现在，撤销修改就是回到添加到暂存区后的状态<h4 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h4>分两步，第一步，把暂存区的修改撤销掉（unstage），重新放回工作区：<br><code>git reset HEAD &lt;file&gt;</code><br>第二步： 撤销工作区的修改<br><code>git checkout -- &lt;file&gt;</code><br>小结：</li><li>当你该乱了工作区某个文件的内容时，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code></li><li>当你不但改乱了工作区的某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>,就回到了第一步，第二步按第一步操作</li><li>当你不但把修改添加到了暂存区（<code>git add &lt;file&gt;</code>）还提交了不适合的修改到版本库时参照命令 <blockquote><p><strong>时光穿梭机-版本回退</strong></p></blockquote><h3 id="时光穿梭机-删除文件"><a href="#时光穿梭机-删除文件" class="headerlink" title="时光穿梭机-删除文件"></a>时光穿梭机-删除文件</h3>一般情况下，你通常直接在文件管理器中把没用的文件删除了，或者用rm命令（linux专用命令）删了（前提是你把文件提交到版本库中去了）<br><code>git rm &lt;file&gt;</code><br><code>git rm &lt;file&gt;</code>相当于执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="进一步解释"><a href="#进一步解释" class="headerlink" title="进一步解释"></a>进一步解释</h4><p>Q:比如执行了<code>rm text.txt</code>误删了怎么办？A：执行<code>git checkout -- text.txt</code>把版本库的东西重新写回工作区就行了<br>Q:如果执行了<code>git rm text.txt</code>我们会发现工作区的text.txt文件也删除了，怎么恢复？A:先撤销暂存区的修改，重新放回工作区，然后再从版本库写会道工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD text.txt</span><br><span class="line">git checkout -- text.txt</span><br></pre></td></tr></table></figure></p><p>Q:如果真的想从版本库中删除文件怎么办？A:执行<code>git commit -m &quot;delete text.txt&quot;</code>,提交后最新的版本库将不包含这个文件<br>小结：</p><ol><li>直接用<code>git rm &lt;file&gt;</code>和<code>git commit -m &quot;msg&quot;</code>直接把文件从版本库中删除</li><li>使用<code>git checkout &lt;file&gt;</code>无论工作区是修改和删除都可以一键还原（实际上是用版本库中的版本替换工作区的版本）</li></ol><h3 id="时光穿梭机-版本回退"><a href="#时光穿梭机-版本回退" class="headerlink" title="时光穿梭机-版本回退"></a>时光穿梭机-版本回退</h3><p><strong>你不断对文件进行修改，然后不断提交到版本库里（前提是你先后执行了<code>git add和git commit命令</code>）</strong></p><ol><li>在版本间进行穿梭：<br>HEAD指向的版本就是当前的版本，因此，Git允许我们在版本历史之间穿梭，使用命令<code>git reset --hard commit_id</code></li><li>穿梭到历史版本：<br>使用<code>git log</code>或者<code>git log --pretty=oneline</code>（只会显示关键信息，比较简洁方便查看）可以查看提交历史（可以查看不同时间的版本和版本ID），以便确定要回退到哪个版本,然后使用命令1回退版本</li><li>重返未来<br>使用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h3>Git鼓励大量使用分支<br>查看分支：git branch(名字前面带*号表示当前分支)<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支： git checkout -b <name><br>合并某分支到当前分支 ： git merge <name><br>删除分支： git branch -d <name><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3></name></name></name></name></name></li></ol><ul><li>当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</li><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容再提交</li><li>用<code>git log --graph</code>命令可以看到分支合并图<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3>通常，合并分支时，如果可能，git会用<code>fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息<br>如果强制禁用<code>fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息<br>第一步：<br>首先我们需要创建并切换dev分支<code>git checkout -b dev</code><br>第二步：<br>修改相关文件如reade.txt，并提交一个新的commit<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add reade.txt</span><br><span class="line">git commit -m &quot;add merge&quot;</span><br></pre></td></tr></table></figure></li></ul><p>第三步：<br>我们切回master<br><code>git checkout master</code><br>第四步：<br>准备合并分支，请注意<code>--no-ff</code>参数，表示禁用<code>fast forward</code>使用如下命令<br><code>git merge --no-ff -m &quot;merge with no-ff</code><br>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去<br>第五步：<br>我们用<code>git log --graph --pretty=oneline --abbrev-commit</code>命令查看分支历史（比<code>git log</code>好就好在可以看到合并历史，当然是不适用<code>fast forward</code>模式的合并）</p><ul><li>master分支是非常稳定的，也就是仅用来发布最新版本，平时不能在上面干活</li><li>平时干活都应该在dev分支上，也就是说dev分支是不稳定的，在dev上干完活后确认dev分支无误后在把dev<br>分支合并到master上</li><li>合并分支时加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能够看出来曾经做过合并<br>而fast forward合并就看不出来曾经做过合并<h3 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h3>当你在dev分支中开发自己的功能时你在提交前遇到了bug所以不能够提交如何做呢？</li><li>首先你应该把当前的工作现场储藏起来使用如下命令<br><code>git stash</code></li><li><p>首先你要先确定要在哪个分支上修复bug，假定要在master分支上修复，就从master创建临时分支例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master//切换到分支master</span><br><span class="line">git checkout -b issue-101//创建分支issue-101并且切换到分支issue-101</span><br></pre></td></tr></table></figure></li><li><p>然后可以进文件中修复bug,并且执行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;fix bug lo1&quot;</span><br></pre></td></tr></table></figure></li><li><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge issue-101 --no-ff -m &quot;merged bug fix 101&quot;</span><br><span class="line">git branch -d issue-101</span><br></pre></td></tr></table></figure></li><li><p>接着回到dev干活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></li><li><p>使用如下命令查看stash的目录列表<br><code>git stash list</code><br>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法<br>第一个办法：<br><code>git stash apply</code>恢复工作现场，但是不删除stash内容，你需要用<code>git stash drop</code>来删除<br>当然你也可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令<br><code>git stash apply stash@{0}</code>(关于apply后面的参数可以通过<code>git stash list</code>查看并获取)<br>第二个办法：<br><code>git stash pop</code>恢复工作现场，同时删除stash内容<br>总结：</p></li><li>修复bug的时候，我们会通过创建新的bug分支进行修复，然后合并，最后删除</li><li>当手头的工作没有完成的时候，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场<h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3></li><li>开发一个新的feature（功能），最好新建一个分支，如在dev上新建一个vulcan分支用于宇宙飞船项目</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3>首先那些分支需要需要推送那些分支不需要推送？</li><li>master分支是主分支要时刻与远程同步</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li><li>bug分支只用于在本地修复bug，就没有必要推送到远程了</li><li>feature分支是否推送到远程，取决于你是否和你的小伙伴合作在上面开发<br>协作过程：<br>多人协作时，大家都会往master和dev分支上推送各自的修改<br>第一步：<br><code>git clone http地址/ssl地址</code>值得注意的是从远程克隆时，默认情况下，你的小伙伴只能看到本地的master分支<br>第二步：<br>当你的小伙伴需要在dev分支上进行开发时，就必须创建远程origin的dev分支到本地使用如下命令<br><code>git checkout -b dev origin/dev</code><br>第三步：<br>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程具体使用如下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;add env&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></li></ul><p>第四步：<br>如果推送失败说明远程分支比你的本地分支更新，需要先用<code>git pull</code>试图合并<br>如果<code>git pull</code>失败并提示<code>no tracking information</code>说明本地分支和远程分支的链接关系没有建立,使用如下命令<code>git branch --set-upstream-to=origin/dev dev</code><br>如果<code>git pull</code>成功合并但是有冲突，那么先解决冲突，并在本地提交<br>第五步：<br>没有冲突或者解决冲突后，再用<code>git push origin &lt;branch-name&gt;</code></p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比<br>适用范围：</li><li>只对尚未推送或者分享给别人的本地修改执行变基操作</li><li>不对已推送至别处的提交执行变基操作<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2>发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样就唯一确定了打标签时刻的版本，将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以标签也是版本库的一个快照<br><code>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</code><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3></li><li>使用如下命令就可创建标签<br><code>git tag v1.0</code><br>默认是HEAD,也可以指定一个commit_id如下例<br><code>git tag v1.0 f52c653</code></li><li>可以用命令查看所有标签<br><code>git tag</code></li><li>注意标签不是按时间顺序列出，而是按字母排序的使用如下命令查看标签信息<br><code>git show &lt;tagname&gt;</code></li><li>创建带有说明的标签，用-a指定标签名，-m指定说明文字如下例子<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3></li><li>推送某个标签到远程使用如下命令<br><code>git push origin &lt;tagname&gt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;这里是我做的关于git学习的笔记，记的也比较详细&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Git</title>
    <link href="http://yoursite.com/2018/11/11/learnGit/"/>
    <id>http://yoursite.com/2018/11/11/learnGit/</id>
    <published>2018-11-11T09:32:33.000Z</published>
    <updated>2018-11-19T01:24:00.623Z</updated>
    
    <content type="html"><![CDATA[<p><code>特别注意本文章主要适合初学者对git一个初步了解，里面的内容不是特别完善和正确</code></p><h3 id="前言（两个问题）"><a href="#前言（两个问题）" class="headerlink" title="前言（两个问题）"></a>前言（两个问题）</h3><h4 id="1-什么是版本控制？我为什么要关心它呢？"><a href="#1-什么是版本控制？我为什么要关心它呢？" class="headerlink" title="1.什么是版本控制？我为什么要关心它呢？"></a>1.什么是版本控制？我为什么要关心它呢？</h4><p><strong>版本控制是记录一个或者若干个文件内容变化，以便将来查阅特定版本修订状况的系统。我们不仅可以对软件源代码的文本文件制作版本管理，我们还可以对任何类型的文件进行版本控制</strong></p><h4 id="2-采用版本控制有什么好处？"><a href="#2-采用版本控制有什么好处？" class="headerlink" title="2.采用版本控制有什么好处？"></a>2.采用版本控制有什么好处？</h4><ol><li><strong>有了它你可以将某个文件回溯到之前的状态，甚至将整个项目都回退过去某个时间点的状态</strong>。</li><li><strong>你可以比较文件的变化细节，查出最后是谁修改了那个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能的缺陷</strong></li><li><strong>使用版本控制系统还意味着即使你把整个项目中的文件改的改删的删，你也可以照样轻松恢复到原先的样子，但是额外增加的工作量却是微乎其微</strong><br><em>github的名字源于Git，Git是一个分布式版本控制系统，让程序员团队能够协作开发项目，git帮助大家管理为项目所作的工作，避免一个人的修改影响其他人所做的修改。你在项目中实现一个新功能的时候，git将跟踪你对每个文件所作的修改，而git将记录项目，如果你犯了错，想撤销所做的修改，可以轻松的返回以前的任何可行状态：代码，项目参与者的信息，问题和bug报告等</em><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h4>Git跟踪谁修改了项目，哪怕参与项目的只有一个人，所以，Git需要知道你的用户名和电子邮件，你必须提供用户名，但可以使用虚构的电子邮件地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@example.com&quot;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意git config命令的–global参数，用了这个参数，表示你对这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定不同的用户名和Email地址</strong></p><h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h4><ol><li>我们来创建一个要进行版本控制的项目（又称版本库）。在你的系统创建一个名为learngit的文件夹使用如下命令<br>mkdir learngit //创建文件learngit<br>cd learngit    //进入learngit文件夹里面<br>dir            //显示learngit存在目录</li><li>我们进入一个文件管理系统，进入learngit文件夹中创建一个hello-world.html文件在里面写上<br>console.log(‘Hello World’)  //注意html5的格式还是要有的<h4 id="3-初始化仓库"><a href="#3-初始化仓库" class="headerlink" title="3.初始化仓库"></a>3.初始化仓库</h4>使用以下命令创建一个git仓库<br><code>git init</code><br>然后会出现提示信息提示你创建了一个空的git仓库<h4 id="4-进行其他操作前先检查下状态使用如下命令"><a href="#4-进行其他操作前先检查下状态使用如下命令" class="headerlink" title="4.进行其他操作前先检查下状态使用如下命令"></a>4.进行其他操作前先检查下状态使用如下命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">   (use &quot;git add &lt;file&gt;...&quot; to include in what will be commited)</span><br><span class="line">                hello_world.html</span><br><span class="line">    nothing added to commit but untracked files present </span><br><span class="line">    (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></li></ol><p>在git中分支是项目的一个版本，从这里的输出我们可以知道，我们位于分支的master</p><p>我们每次查看项目的时候，输出都是我们位于分支master上，接下来的输出表明，我将进行项目的提交，提交时项目在特定时间的快照</p><p>Git指出了项目中未被跟踪的文件，因为我们还没有告诉他要跟踪那些文件，接下来我们被告知没有任何东西添加到当前提交里面，我们需要将要跟踪的文件加入到仓库</p><h4 id="5-将文件加入到仓库"><a href="#5-将文件加入到仓库" class="headerlink" title="5.将文件加入到仓库"></a>5.将文件加入到仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">/learngit(master)</span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">      (use &quot;git rm --cached &lt;file&gt;)</span><br><span class="line">          </span><br><span class="line">          new file: hello-world.html</span><br></pre></td></tr></table></figure><p><code>git add .</code> <strong>将项目中未被跟踪的文件都加入到仓库中</strong>，它不提交这些文件，而是让git开始关注他们。现在我们检查这个项目的状态，发现Git找到了需要提交的文件的一些修改，标签new file 表示这些文件是新加入的</p><h4 id="6-执行提交"><a href="#6-执行提交" class="headerlink" title="6.执行提交"></a>6.执行提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Started project&quot;</span><br><span class="line">[master(root-commit) 5d6cecal] Started project</span><br><span class="line">  1 file changed, 1 insertion(+)</span><br><span class="line">  create mode 1006444 hello-world.html</span><br></pre></td></tr></table></figure><p>我们在执行<code>git commit -m &quot;Started project&quot;</code> 的时候，<strong>是拍摄项目快照</strong> <code>-m</code><strong>是让Git接下来的消息记录到项目的历史纪录中</strong>，输出表明我们在分支master上，而且有一个文件被修改了 <code>-m</code><strong>后面输入的内容是本次提交的说明</strong>，可以输入任意内容，当然最好是有意义的，这样你就从历史记录中方便地找到改动记录</p><h4 id="7-查看提交历史"><a href="#7-查看提交历史" class="headerlink" title="7.查看提交历史"></a>7.查看提交历史</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">commit 5dcfhfhfhhfhfhfhfhhffhhfhfhhfhfhfhfh</span><br><span class="line">(HEAD -&gt; master)</span><br><span class="line">Author: username&lt;xxxxx.example.com&gt;</span><br><span class="line">Date: Sat Dec 9 20:16:17 2017 +0800</span><br><span class="line"></span><br><span class="line">       Started project</span><br></pre></td></tr></table></figure><p>‘git log’是<strong>git日志</strong>的意思<br>我们每次提交的时候，Git都会生成一个包好40字符的独一无二的引用ID，它记录提交是谁执行的，提交时间，以及提交的指定消息，但是不是任何情况下都需要所有这些信息，因此git提供一个选项，让我们能够打印提交历史条目的更简单版本<br><figure class="highlight plain"><figcaption><span>log --pretty</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fhhfhfhfhhfhd34hfhfh676hfrhffh(HEAD -&gt; master)</span><br><span class="line"> Started project</span><br></pre></td></tr></table></figure></p><p> 标志 –pretty=oneline（指定显示一项重要的内容（提交的引用ID以及为提交记录的消息））</p><h4 id="8-第二次提交"><a href="#8-第二次提交" class="headerlink" title="8.第二次提交"></a>8.第二次提交</h4><p> 为了显示版本控制的强大，我们需要对项目进行修改，并提交所做的修改，为此，我们在文件中再添加一行代码<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;Hello World&apos;)</span><br><span class="line">console.log(&quot;Hello git&quot;)</span><br></pre></td></tr></table></figure></p><p>如果我们查看项目的状态，将发现Git注意到了这个文件的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">    (use &quot;git add &lt;file&gt;...&quot; to update what will be commited)</span><br><span class="line">    (use &quot;git checkout--&lt;file&gt;...&quot; to discared changes in working directory)</span><br><span class="line">        modified : hello-world.html</span><br><span class="line">No changes added on commit (use &quot;git add&quot;and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p><p>这个指出了我们当前所在的分支为master，其中做出修改的文件是hello-world.html,而且所做的修改还没有提交<br>接下来我们提交所做的修改，并且查看操作</p><ul><li><p>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &quot;Extrending greeting&quot;</span><br><span class="line">[master b4ee15d] Extrended greeting.</span><br><span class="line"> 1 file changed, 2 insertion(+), 1 deletiong(-)</span><br></pre></td></tr></table></figure></li><li><p>查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit,working tree clen</span><br></pre></td></tr></table></figure></li><li><p>查看提交历史中重要信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneling</span><br><span class="line">b4ee15dfhfhfhfhfhfhhfhfhfhfhfhhfhhfhfhfhfhfhryrytyfhfh(HEAD -&gt; master)</span><br><span class="line">   Extrending greeting</span><br><span class="line">5d6cecafhfheyedfdjafoefhoehvfhefheofheofhcncnahffhdefh Started project</span><br></pre></td></tr></table></figure></li></ul><p>上面的解释是：我们执行提交，并且执行git commit的时候制定了标志-am其中<code>-a</code>是让Git将仓库中所有修改了的文件都加入当前提交中（如果我们两次提交之间加入了新文件，我们执行<code>git add .</code>操作，将新文件加入到仓库中）标志<code>-m</code>让Git在提交历史中记录一条消息</p><h4 id="9-撤销更改"><a href="#9-撤销更改" class="headerlink" title="9.撤销更改"></a>9.撤销更改</h4><ul><li><code>git checkout .</code>放弃最后一次提交对这个文件所做所有操作，将项目恢复到最后一次提交的状态</li><li><code>git checkout</code> 引用ID的前6个字符` 放弃最近所做的工作，回到指定的以前的提交</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;特别注意本文章主要适合初学者对git一个初步了解，里面的内容不是特别完善和正确&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言（两个问题）&quot;&gt;&lt;a href=&quot;#前言（两个问题）&quot; class=&quot;headerlink&quot; title=&quot;前言（两个问题）&quot;&gt;&lt;/a&gt;前言（两个问题）&lt;/h3&gt;&lt;h4 id=&quot;1-什么是版本控制？我为什么要关心它呢？&quot;&gt;&lt;a href=&quot;#1-什么是版本控制？我为什么要关心它呢？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是版本控制？我为什么要关心它呢？&quot;&gt;&lt;/a&gt;1.什么是版本控制？我为什么要关心它呢？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;版本控制是记录一个或者若干个文件内容变化，以便将来查阅特定版本修订状况的系统。我们不仅可以对软件源代码的文本文件制作版本管理，我们还可以对任何类型的文件进行版本控制&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-采用版本控制有什么好处？&quot;&gt;&lt;a href=&quot;#2-采用版本控制有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;2.采用版本控制有什么好处？&quot;&gt;&lt;/a&gt;2.采用版本控制有什么好处？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;有了它你可以将某个文件回溯到之前的状态，甚至将整个项目都回退过去某个时间点的状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你可以比较文件的变化细节，查出最后是谁修改了那个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能的缺陷&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用版本控制系统还意味着即使你把整个项目中的文件改的改删的删，你也可以照样轻松恢复到原先的样子，但是额外增加的工作量却是微乎其微&lt;/strong&gt;&lt;br&gt;&lt;em&gt;github的名字源于Git，Git是一个分布式版本控制系统，让程序员团队能够协作开发项目，git帮助大家管理为项目所作的工作，避免一个人的修改影响其他人所做的修改。你在项目中实现一个新功能的时候，git将跟踪你对每个文件所作的修改，而git将记录项目，如果你犯了错，想撤销所做的修改，可以轻松的返回以前的任何可行状态：代码，项目参与者的信息，问题和bug报告等&lt;/em&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>settingBlog</title>
    <link href="http://yoursite.com/2018/11/09/settingBlog/"/>
    <id>http://yoursite.com/2018/11/09/settingBlog/</id>
    <published>2018-11-09T07:01:55.000Z</published>
    <updated>2018-11-19T01:23:47.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前看到有人搭建自己的博客，觉得自己有机会一定要试试，至于搭建博客的原因，自己搭建博客的话，样式的选择比较自由，可以自己选择，不受限于各大平台，另外我也想把这个自己搭建的平台当成自己记录笔记的一个方式，平时自己学习的东西可以通过这个平台方便以后记忆，同时有时候你也可以分享给别人自己的一些学习成果<br><a id="more"></a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>搭建环境准备（包括node.js和git环境，github账户的设置）</li><li>安装Hexo</li><li>配置Hexo</li><li>选择主题</li><li>怎样将Hexo与github page联系起来</li><li>怎样发布文章<h4 id="1-搭建环境准备"><a href="#1-搭建环境准备" class="headerlink" title="1.搭建环境准备"></a>1.搭建环境准备</h4></li></ol><ul><li>首先安装你的电脑必须安装node.js（最好全局安装方便以后使用）</li><li>安装完成后打开cmd命令面板使用以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ul><p>如果可以看到版本号说明安装成功</p><ul><li>进入git官网安装git，安装的时候看下图<br><img src="/2018/11/09/settingBlog/01.jpg" alt="git安装"><br>处于安全考虑，只有在git Bash中才能进行git的相关操作。安装上图进行选择，将会使得git安装程序在系统PATH中加入git的相关路径，使得你可以在cmd界面下调用git，不用打开git Bash<br>安装完成后在cmd中输入<br><code>git --version</code><br>如果可以看到版本号说明安装成功，如果不正确则要回头检查自己的安装过程<h4 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h4>在自己认为合适的地方创建一个文件夹，这里以我自己D/Hexo为例子，在D盘目录下创建一个Hexo文件夹<br>，并在命令行窗口进入到该目录<br>在命令行中输入<br><code>npm install hexo-cli -g</code><br>然后使用如下命令安装<br><code>npm install hexo --save</code><br>安装完成后在命令行中输入<br><code>hexo -v</code><br>如果可以看到hexo的版本号说明安装成功<h4 id="3-配置Hexo"><a href="#3-配置Hexo" class="headerlink" title="3.配置Hexo"></a>3.配置Hexo</h4>初始化你的项目输入<br><code>hexo init yourproject</code><br>我的是myproject<br>然后输入以下命令安装依赖<br><code>npm install</code><h5 id="首次体验Hexo"><a href="#首次体验Hexo" class="headerlink" title="首次体验Hexo"></a>首次体验Hexo</h5>继续操作在命令行中输入<br><code>hexo g</code><br>然后输入<br><code>hexo s</code><br>在浏览器打开<a href="http://localhost:4000，你将会看到一个hexo页面，如果看到说明成功配置Hexo" target="_blank" rel="noopener">http://localhost:4000，你将会看到一个hexo页面，如果看到说明成功配置Hexo</a><h4 id="4-选择主题"><a href="#4-选择主题" class="headerlink" title="4.选择主题"></a>4.选择主题</h4></li><li>在站点根目录输入（我的是D://hexo/myproject)<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></li><li>完成后，打开站点配置文件，找到theme字段，并将其值更改为next<blockquote><p>配置文件就是根目录下的_config.yml文件<br><code>theme: next</code></p></blockquote></li><li>在终端输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean //清除缓存</span><br><span class="line">hexo g //重新生成代码</span><br><span class="line">hexo s //部署到本地</span><br></pre></td></tr></table></figure></li></ul><p>然后打开浏览器访问localhost:4000<br>查看效果<br>next主题有三种选择，这个只是最简洁的一种，我们选择最好看的那个</p><blockquote><p>Muse-默认scheme，这是next最初的版本，黑白主调，大量留白<br>Mist-Muse的紧凑版本，整洁有序的单栏外观<br>Pisces-双栏的scheme，小家碧玉的清新</p><ol start="4"><li>配置NexT<br>在站点根目录/themes/next/_config.yml 文件中修改<br><code>scheme: Pisces</code><br>然后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean //清除缓存</span><br><span class="line">hexo g //重新生成代码</span><br><span class="line">hexo s //部署到本地</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>当然，你完全可以进行很多的自定义设置甚至修改源码，定制自己的主题，跟多的设置请移步官方文档<br><code>https://theme-next.iissnan.com/getting-started.html</code></p><h4 id="5-将Hexo与github-page联系起来"><a href="#5-将Hexo与github-page联系起来" class="headerlink" title="5.将Hexo与github page联系起来"></a>5.将Hexo与github page联系起来</h4><p>首先你先要在github官网注册一个账号，然后创建一个仓库具体如何创建可以百度相关教程<br>布置完成仓库后你可以得到一个链接，访问这个链接，你可以得到一个页面，如果看到了这个页面说明成功了</p><h4 id="6-发布文章"><a href="#6-发布文章" class="headerlink" title="6.发布文章"></a>6.发布文章</h4><p>使用如下命令<br>首先<br><code>hexo new post &#39;titile&#39;</code><br>这是在source中新建一个_post文件夹你可以在D://hexo/myproject/source中看到<br>先做个清理防止配置<br>接下来是Hexo生成<br><code>hexo g</code><br>然后是Hexo部署(你先要安装一个插件使用<code>npm install hexo-deployer-git --save</code>)<br>你的所有安装的插件都可以在pack.json中看到<br><code>hexo d</code><br>当然你也可以写到一起<br><code>hexo d -g</code><br><code>hexo g -d</code><br>两者的效果是一样的<br>然后使用<br><code>hexo s</code><br>最后使用github中的你得到的链接访问看看效果</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;以前看到有人搭建自己的博客，觉得自己有机会一定要试试，至于搭建博客的原因，自己搭建博客的话，样式的选择比较自由，可以自己选择，不受限于各大平台，另外我也想把这个自己搭建的平台当成自己记录笔记的一个方式，平时自己学习的东西可以通过这个平台方便以后记忆，同时有时候你也可以分享给别人自己的一些学习成果&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>insertImage</title>
    <link href="http://yoursite.com/2018/11/08/insertImage/"/>
    <id>http://yoursite.com/2018/11/08/insertImage/</id>
    <published>2018-11-08T15:07:40.000Z</published>
    <updated>2018-11-09T10:28:06.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="向文章中添加图片"><a href="#向文章中添加图片" class="headerlink" title="向文章中添加图片"></a>向文章中添加图片</h3><p>使用官方的方式我觉的太麻烦，所以查找资料并结合本人的实践找到了以下的方法<br><a id="more"></a></p><ol><li>首先修改站点配置文件_config.yml中的post_asset_folder（随后你生成的draft或post都会附带一个与文章同名的目录）图片放在这个目录中就可以了<br><code>post_asset_folder: true</code></li><li>在hexo你的项目目录下（我的是myproject）执行npm install asset-image –save,这是下载安装一个上传本地图片的插件</li><li>稍等片刻hexo new post “title”生成md博文时，/source/_post文件夹里除了有:year/:month/:day:/title.md文件还有一个同名的文件夹</li><li><code>![这里输入图片描述](图片名.jpg)</code><br>下面来张傻狗图片镇楼<br><img src="/2018/11/08/insertImage/fool-dog.jpeg" alt="chan"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;向文章中添加图片&quot;&gt;&lt;a href=&quot;#向文章中添加图片&quot; class=&quot;headerlink&quot; title=&quot;向文章中添加图片&quot;&gt;&lt;/a&gt;向文章中添加图片&lt;/h3&gt;&lt;p&gt;使用官方的方式我觉的太麻烦，所以查找资料并结合本人的实践找到了以下的方法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>markdown基本语法</title>
    <link href="http://yoursite.com/2018/11/05/article-title/"/>
    <id>http://yoursite.com/2018/11/05/article-title/</id>
    <published>2018-11-05T08:19:39.292Z</published>
    <updated>2018-11-09T10:27:33.094Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言："><a href="#序言：" class="headerlink" title="序言："></a>序言：</h3><p>写一篇博客关于markdown的基本语法，方便现在学习和以后复习</p><h3 id="起因："><a href="#起因：" class="headerlink" title="起因："></a>起因：</h3><p>现在的前端基本都用上了前端构建工具，那就难免要写一些readme等等的说明性文件<br>这样编写的文件一般都是.md文件，编写的语法自然跟其他格式的文件有所区别<br>本文是markdown文件的一个笔记，仅供学习和参考<br><a id="more"></a></p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><ol><li>标题的几种写法<br><strong>第一种</strong>：<h1 id="一级标题写法"><a href="#一级标题写法" class="headerlink" title="一级标题写法"></a>一级标题写法</h1><h2 id="二级标题写法"><a href="#二级标题写法" class="headerlink" title="二级标题写法"></a>二级标题写法</h2><h3 id="三级标题写法"><a href="#三级标题写法" class="headerlink" title="三级标题写法"></a>三级标题写法</h3><h4 id="四级标题写法"><a href="#四级标题写法" class="headerlink" title="四级标题写法"></a>四级标题写法</h4><h5 id="五级标题写法"><a href="#五级标题写法" class="headerlink" title="五级标题写法"></a>五级标题写法</h5><h6 id="六级标题写法"><a href="#六级标题写法" class="headerlink" title="六级标题写法"></a>六级标题写法</h6>####### 七级标题写法<br><img src="https://zbsthink.github.io/images/title-usage.jpg" alt="标题写法"><br>前面带#号，后面带文字，分别表示h1-h6，上面可以看出，直到h6,而且h1下面会有一条横线，<br>注意： #号后面有空格<br><strong>第二种</strong>：<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1>这是二级标题</li></ol><hr><p><img src="https://zbsthink.github.io/images/title-usage1.jpg" alt="标题写法2"><br>这种方式只能表示一级和二级标题，而且=和-的数量好像没有限制，只要大于一个就行<br><strong>第三种</strong>：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p><img src="https://zbsthink.github.io/images/title-usage2.jpg" alt="标题写法1"><br>这种方式也可以表示h1-h6标题</p><ol start="2"><li>列表的几种写法<br>我们都知道列表分为有序列表和无需列表，下面我们直接展示2种列表的写法<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3></li></ol><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>1</li><li>1<br><img src="https://zbsthink.github.io/images/disorder-list.jpg" alt="无序列表"><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3></li></ul><ol><li>list1</li><li>list2</li><li>list3<br><img src="https://zbsthink.github.io/images/order-list.jpg" alt="有序列表"><br>有序列表就相对简单一点，只有一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的序号根据第一行列表的数字顺序来的，比如说：<h3 id="有序列表-1"><a href="#有序列表-1" class="headerlink" title="有序列表"></a>有序列表</h3></li><li>list1</li><li>list2</li><li>list3<br><img src="https://zbsthink.github.io/images/order-list1.jpg" alt="有序列表1"></li></ol><hr><ol start="3"><li>区块引用<h2 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h2></li></ol><ul><li>不以结婚为目的的恋爱都是耍流氓<blockquote><p>这是毛主席说的</p></blockquote></li><li>前方高能<blockquote><p>注意：这里是为了提醒有刺激的事情即将发生，请做好准备<br><img src="https://zbsthink.github.io/images/reference-normal.jpg" alt="普通引用"></p></blockquote></li></ul><p>引用的用法就是在语句前面加一个&gt;,注意是英文的那个右尖括号，注意空格<br>引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看下方实例</p><blockquote><h3 id="名人名言"><a href="#名人名言" class="headerlink" title="名人名言"></a>名人名言</h3><ul><li>不以结婚为目的都是耍流氓<blockquote><p>——毛主席</p></blockquote></li><li>高举中国特色社会主义伟大旗帜<blockquote><p>——习大大</p></blockquote></li></ul></blockquote><p><img src="https://zbsthink.github.io/images/reference-nested.jpg" alt="嵌套引用"><br>上面的代码全部加上引用标签就变成了一个大的引用，引用里面还有引用</p><h2 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h2><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p><blockquote><p>五级引用</p><blockquote><p>六级引用</p><blockquote><p>七级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p><img src="https://zbsthink.github.io/images/reference-nested1.jpg" alt="嵌套引用1"><br>上面可以看出，想要在上一次引用中嵌套一层引用，只需要多加一个&gt;,理论上可以无限嵌套，注意：多层嵌套&gt;是不需要<br>连续在一起，只要在一行就可以了，中间允许空格，但是为了好看，还是需要把排版搞好</p><ol start="4"><li>华丽的分割线</li></ol><hr><hr><hr><hr><hr><hr><hr><p><img src="https://zbsthink.github.io/images/dividing-line.jpg" alt="分割线"><br>分隔线可以由* - _(星号，减号，下划线)这3个符号的至少3个符号表示，注意至少要3个，且需要连续，有空格也可以</p><ol start="5"><li>链接<br>支持两种链接方式：行内式和参数式，不管是哪一种，链接文字都是用[方括号]来标记<h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT使用文档</a><br><img src="https://zbsthink.github.io/images/inline1.jpg" alt="行内式"><h3 id="列表链接"><a href="#列表链接" class="headerlink" title="列表链接"></a>列表链接</h3></li></ol><ul><li><a href="https://www.baidu.com" title="参数1" target="_blank" rel="noopener">列表1</a></li><li><a href="https://www.baidu.com" title="参数2" target="_blank" rel="noopener">列表2</a><br><img src="https://zbsthink.github.io/images/inline2.jpg" alt="列表链接"><h3 id="参数式"><a href="#参数式" class="headerlink" title="参数式"></a>参数式</h3></li></ul><p>这里是参数1<a href="https://www.baidu.com" title="参数1" target="_blank" rel="noopener">name</a>,这里是参数2<a href="https://www.baidu.com" title="参数2" target="_blank" rel="noopener">home</a><br><img src="https://zbsthink.github.io/images/para.jpg" alt="参数式"><br>实际上就是把链接当作参数，适合多次使用链接的场景</p><ol start="6"><li><p>图片<br>图片也有两种方式，行内式和参数式</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>引用图片1</strong><br>1.行内式<br><img src="https://zbsthink.github.io/images/photo1.jpg" alt="photo1"><br><img src="https://zbsthink.github.io/images/reference-image.jpg" alt="引用图片"></p><p><a href="https://zbsthink.github.io/images/photo1.jpg" target="_blank" rel="noopener">博客园</a><br>参数式图片，这里是 ![博客园]<br><img src="https://zbsthink.github.io/images/reference-image1.jpg" alt="引用图片"><br>用法跟链接基本一样，唯一不同的是，图片前面要写上一个！</p></li><li>代码框<h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><code>&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;</code><br><img src="https://zbsthink.github.io/images/single-code.jpg" alt="单行代码"><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://zbsthink.github.io/images/multiline.jpg" alt="单行代码"></p><ol start="8"><li>表格</li></ol><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">age</th><th style="text-align:center">sex</th></tr></thead><tbody><tr><td style="text-align:center">Tony</td><td style="text-align:center">20</td><td style="text-align:center">男</td></tr><tr><td style="text-align:center">Lucy</td><td style="text-align:center">18</td><td style="text-align:center">女</td></tr></tbody></table><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>content cell</td><td>content cell</td></tr><tr><td>content cell</td><td>content cell</td></tr></tbody></table><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>64</td></tr><tr><td>小虎</td><td>男</td><td>34</td></tr></tbody></table><p><img src="https://zbsthink.github.io/images/table.jpg" alt="单行代码"><br>上面有三种方式用来写表格，表格的格式不一定要对齐，但是为了好看对齐是最好的，第一种的分割线后面的冒号表示<br>对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，但是缺点是表格外面没有边框包起来</p><ol start="9"><li>强调<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><em>字体倾斜</em><br><em>字体倾斜</em><br><strong>字体加粗</strong><br><strong>字体加粗</strong><br><img src="https://zbsthink.github.io/images/qiaodiao.jpg" alt="强调"><br>一个*号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗<br>10.转义<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3></strong></em></li></ol><ul><li>\</li><li>`</li><li>~</li><li>_</li><li>-</li><li>+</li><li>.</li><li>!<br>md文件的转义，基本跟js转义是一样的<br><img src="https://zbsthink.github.io/images/zhuanyi.jpg" alt="转义"></li></ul><ol start="11"><li>删除线<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><del>请删除我吧</del><br><img src="https://zbsthink.github.io/images/shanchu.jpg" alt="删除线"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言：&quot;&gt;&lt;a href=&quot;#序言：&quot; class=&quot;headerlink&quot; title=&quot;序言：&quot;&gt;&lt;/a&gt;序言：&lt;/h3&gt;&lt;p&gt;写一篇博客关于markdown的基本语法，方便现在学习和以后复习&lt;/p&gt;
&lt;h3 id=&quot;起因：&quot;&gt;&lt;a href=&quot;#起因：&quot; class=&quot;headerlink&quot; title=&quot;起因：&quot;&gt;&lt;/a&gt;起因：&lt;/h3&gt;&lt;p&gt;现在的前端基本都用上了前端构建工具，那就难免要写一些readme等等的说明性文件&lt;br&gt;这样编写的文件一般都是.md文件，编写的语法自然跟其他格式的文件有所区别&lt;br&gt;本文是markdown文件的一个笔记，仅供学习和参考&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
  </entry>
  
  <entry>
    <title>给Hexo Next设置阅读全文</title>
    <link href="http://yoursite.com/2018/11/05/hello-world/"/>
    <id>http://yoursite.com/2018/11/05/hello-world/</id>
    <published>2018-11-05T07:05:53.431Z</published>
    <updated>2018-11-09T10:27:27.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近使用Hexo搭建了自己的博客，并且使用了简洁但是强大的NexT主题。这里介绍一下NexT主题下设置在首页显示一篇文章的简介，在简介后面提供一个链接阅读全文来进入文章的详情页<br><a id="more"></a></p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><ol><li><p>在文章中使用&lt; !–more–&gt; 手动进行截断<br>这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。</p></li><li><p>在文章中的front-matter中添加description，并提供文章摘录<br>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。</p></li><li><p>自动形成摘要，在主题配置文件中添加<br>默认截取的长度为 150 字符，可以根据需要自行设定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近使用Hexo搭建了自己的博客，并且使用了简洁但是强大的NexT主题。这里介绍一下NexT主题下设置在首页显示一篇文章的简介，在简介后面提供一个链接阅读全文来进入文章的详情页&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="studyDiary" scheme="http://yoursite.com/categories/studyDiary/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
</feed>
