<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Github的一些简易使用]]></title>
    <url>%2F2018%2F11%2F12%2FlearnGithub%2F</url>
    <content type="text"><![CDATA[Github简介Github是用于版本控制和协作的代码托管平台，它可以让您和其他人在任何地方协同工作，Gihub可以托管各种Git版本库，并提供一个web界面，但与其他像SourceForge或Google Code这样的服务不同，Github的独特卖点在于从另外一个项目进行分支的简易性 如何为一个项目贡献代码？首先点击项目的fork按钮，然后将代码检出并修改加入到刚才分出的代码库中，最后通过内建的pull request机制向项目负责人申请代码合并 本地更新与远程更新的纠葛 远程库更新-&gt;本地更新 第一种方法：get pull origin master(这句话的意思是拉取origin远程仓库master分支并和本地的分支合并，同时更新本地分支)语法： git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;(主机和仓库意思一样)意思是拉取远程仓库的远程分支并与本地分支进行合并，同时更新本地分支例如：git pull origin next:master拉取远程origin仓库的next分支与本地的master分支进行合并，同时更新本地的分支。描述：将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch 后跟 git merge FETCH_HEAD的缩写，更准确的说是使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中，使用–rebase，他运行git rebase 而不是git merge*第二种方法首先查看远程分支:git remote -v第一步：git fetch origin master:temp抓取origin远程仓库的master分支并将其代码下载到本地的temp分支第二步：git diff temp比较本地仓库分支与下载的保存在本地的temp分支确认无误后进行第三步第三步：git merge temp将本地仓库分支与下载的temp合并第四步（非必需）git branch -d temp也可以使用git branch -D &lt;name&gt;强制删除 本地更新-&gt;远程库更新这里的本地有两种一种是自己创建的本地仓库然后进行关联远程github仓库，然后在提交本地修改的文件或者添加文件到本地库，最后推送本地修改的文件到远程github仓库 第一种本地库（自己本地计算机上创建）第一步：在github上创建一个仓库，并且记录下它的地址如https://www.exmple.com第二步：在自己电脑上创建一个文件夹如learnGithub，在里面添加文件如01.html第三步：git操作 第一步：`git init` (生成本地的git管理库) 第二步：`git add .`(将文件添加git管理库中并且添加追踪。如果只想添加某个特定的文件，只需要将.换成特定的名称即可) 第三步：`git commit -m &quot;注释&quot;`举例：`git commit -m &apos;first commit&apos;`(提交暂存区并添加注释-m后面的就是注释) 第四步：`git remote add origin https://自己仓库的url地址`（remote：远程，origin:远程仓库名，整个语句就是关联origin远程库） 第五步： `git push -u origin master`(添加-u表示默认，后买你就可以不加任何参数使用git push了如：`git push origin master`，整句话的意思是上传代码到github远程库) 解释下`git push`命令 git push命令用于将本地分支的更新推送到远程主机。它的格式与git pull命令相似 格式:git push &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 第六步：进入github你所创建的仓库查看 第七步：再次添加文件或者修改了使用`git push origin master`命令 第二种本地库(自己从github上克隆下载到本地，然后在本地进行文件修改或者增加文件然后推送到(push)远程分支即可)-多人协作（在dev分支上进行开发，master主分支只保存最新的成熟的版本） 第一步：首先你要先从远程仓库下载完整内容使用如下命令 git clone http地址或者ssl地址 第二步：你可以在你clone的目录中的文件进行修改或者添加新文件到相关分支如添加到dev分支 git checkout -b dev origin/dev//创建远程origin的dev分支到本地，并切换到本地dev分支 第三步：将最新的更改添加提交后，push到远程的orign/dev使用如下命令 123git add &lt;file&gt;git commit -m &quot;注释语句&quot;git push origin dev 第四步：如果推送失败，这是因为远程分支比你的本地版本更新，需要先用git pull试图合并 如果git pull失败，并提示no tracking information则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to=origin/dev dev;如果git pull &#39;成功了但是有冲突，那么就先解决冲突（删除相关语句或者重写相关语句）然后再git commit -m ‘注释语句’和git push origin dev`多人协作就此完成 多人协作远程库更新分支是一次处理不同版本的存储库的方法默认情况下，我们的存储库有一个名为master的权威分支branch，该分支被认为是权威分支。当你在分支机构上创建master分支时，我们正在制作该master时间点的副本或者快照，如果其他人创建了master分支并且做出更改时我们可以拉取请求（pull）和合并（merge）来更新master这里是关于Github中分支的学习]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepLearnGit]]></title>
    <url>%2F2018%2F11%2F11%2FdeepLearnGit%2F</url>
    <content type="text"><![CDATA[这里是我做的关于git学习的笔记，记的也比较详细 Git介绍 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git SVN和Git的主要区别在于历史版本维护的位置 Git本地仓库包含代码库还有历史库，在本地环境开发就可以记录历史，而SVN的历史库存于中央仓库，每次对比于提交代码都必须连接到中央仓库才能进行 这样的好处在于 自己可以在脱机的情况下查看开发的历史版本 多人开发时如果中央仓库Git仓库挂了，可以随时创建一个新的中央仓库然后就立刻恢复到了中央库Git命令Git配置12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot; git config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址 创建版本库初始化一个Git仓库git init 添加文件到Git仓库包括两步：12git add &lt;file&gt;git commit -m &quot;decription&quot; git add可以反复使用，添加多个文件，git commit可以一次性提交很多文件，-m后输入的是本次提交的说明，可以输入任意内容 查看工作区状态git status 查看修改的内容总共有三个分别是：git diff git diff --cached git diff HEAD -- &lt;file&gt; git diff可以查看工作区（work dict）和暂存区（stage）的区别 git diff --cached 可以查看暂存区（stage）和分支(master)的区别 git diff HEAD -- &lt;file&gt;可以查看工作区和版本库里面最新版本的区别工作区、暂存区和版本库工作区：在电脑里面能看到的目录版本库：在工作区又一个隐藏目录.git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支时光穿梭机工作区和暂存区时光穿梭机-撤销修改前提是你的文件以前使用过git add &lt;file&gt;丢弃工作区的修改git checkout -- &lt;file&gt;该命令是指文件在工作区的修改全部撤销，这里有两种情况: 一种是flie自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种时候file已经添加到暂存区，又做了修改，现在，撤销修改就是回到添加到暂存区后的状态丢弃暂存区的修改分两步，第一步，把暂存区的修改撤销掉（unstage），重新放回工作区：git reset HEAD &lt;file&gt;第二步： 撤销工作区的修改git checkout -- &lt;file&gt;小结： 当你该乱了工作区某个文件的内容时，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt; 当你不但改乱了工作区的某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;,就回到了第一步，第二步按第一步操作 当你不但把修改添加到了暂存区（git add &lt;file&gt;）还提交了不适合的修改到版本库时参照命令 时光穿梭机-版本回退 时光穿梭机-删除文件一般情况下，你通常直接在文件管理器中把没用的文件删除了，或者用rm命令（linux专用命令）删了（前提是你把文件提交到版本库中去了）git rm &lt;file&gt;git rm &lt;file&gt;相当于执行12git rm &lt;file&gt;git add &lt;file&gt; 进一步解释Q:比如执行了rm text.txt误删了怎么办？A：执行git checkout -- text.txt把版本库的东西重新写回工作区就行了Q:如果执行了git rm text.txt我们会发现工作区的text.txt文件也删除了，怎么恢复？A:先撤销暂存区的修改，重新放回工作区，然后再从版本库写回到工作区12git reset HEAD text.txtgit checkout -- text.txt Q:如果真的想从版本库中删除文件怎么办？A:执行git commit -m &quot;delete text.txt&quot;,提交后最新的版本库将不包含这个文件小结： 直接用git rm &lt;file&gt;和git commit -m &quot;msg&quot;直接把文件从版本库中删除 使用git checkout &lt;file&gt;无论工作区是修改和删除都可以一键还原（实际上是用版本库中的版本替换工作区的版本） 时光穿梭机-版本回退你不断对文件进行修改，然后不断提交到版本库里（前提是你先后执行了git add和git commit命令） 在版本间进行穿梭：HEAD指向的版本就是当前的版本，因此，Git允许我们在版本历史之间穿梭，使用命令git reset --hard commit_id 穿梭到历史版本：使用git log或者git log --pretty=oneline（只会显示关键信息，比较简洁方便查看）可以查看提交历史（可以查看不同时间的版本和版本ID），以便确定要回退到哪个版本,然后使用命令1回退版本 重返未来使用git reflog查看命令历史，以便确定要回到未来的哪个版本远程仓库创建SSH Keyssh-keygen -t rsa -C &quot;your email&quot;关联远程仓库git remote add origin http地址或者ssh地址推送到远程库git push -u origin master(远程仓库分支名)-u表示第一推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新的修改从远程克隆git clone http地址或ssh地址分支管理创建合并分支Git鼓励大量使用分支查看分支：git branch(名字前面带号表示当前分支) 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支： git checkout -b &lt;name&gt; 合并某分支到当前分支 ： git merge &lt;name&gt; 删除分支： git branch -d &lt;name&gt; 丢弃一个没有合并过的分支：git branch -D &lt;branch-name&gt; 查看分支合并图：git log --graph --pretty=oneline --abbrev-commit 普通模式合并分支*：git merge --no-ff -m &quot;description解决冲突 当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容再提交 用git log --graph命令可以看到分支合并图分支管理策略通常，合并分支时，如果可能，git会用fast forward模式，但这种模式下，删除分支后，会丢掉分支信息如果强制禁用fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息禁用fast forward模式的--no-ff合并第一步：首先我们需要创建并切换dev分支git checkout -b dev第二步：修改相关文件如reade.txt，并提交一个新的commit12git add reade.txtgit commit -m &quot;add merge&quot; 第三步：我们切回mastergit checkout master第四步：准备合并分支，请注意--no-ff参数，表示禁用fast forward使用如下命令git merge --no-ff -m &quot;merge with no-ff因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去第五步：我们用git log --graph --pretty=oneline --abbrev-commit命令查看分支历史（比git log好就好在可以看到合并历史，当然是不适用fast forward模式的合并）小结 master分支是非常稳定的，也就是仅用来发布最新版本，平时不能在上面干活 平时干活都应该在dev分支上，也就是说dev分支是不稳定的，在dev上干完活后确认dev分支无误后在把dev分支合并到master上 合并分支时加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能够看出来曾经做过合并而fast forward合并就看不出来曾经做过合并bug分支当你在dev分支中开发自己的功能时你在提交前遇到了bug所以不能够提交如何做呢？ 首先你应该把当前的工作现场储藏起来使用如下命令git stash 首先你要先确定要在哪个分支上修复bug，假定要在master分支上修复，就从master创建临时分支例如 12git checkout master//切换到分支mastergit checkout -b issue-101//创建分支issue-101并且切换到分支issue-101 然后可以进文件中修复bug,并且执行以下操作 12git add &lt;file&gt;git commit -m &quot;fix bug lo1&quot; 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支 123git checkout mastergit merge issue-101 --no-ff -m &quot;merged bug fix 101&quot;git branch -d issue-101 接着回到dev干活 1git checkout dev 使用如下命令查看工作现场git stash list工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法第一个办法：git stash apply恢复工作现场，但是不删除stash内容，你需要用git stash drop来删除当然你也可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令git stash apply stash@{0}(关于apply后面的参数可以通过git stash list查看并获取)第二个办法：git stash pop恢复工作现场，同时删除stash内容总结： 修复bug的时候，我们会通过创建新的bug分支进行修复，然后合并，最后删除 当手头的工作没有完成的时候，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场feature分支 开发一个新的feature（功能），最好新建一个分支，如在dev上新建一个vulcan分支用于宇宙飞船项目 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除多人协作首先那些分支需要需要推送那些分支不需要推送？ master分支是主分支要时刻与远程同步 dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于在本地修复bug，就没有必要推送到远程了 feature分支是否推送到远程，取决于你是否和你的小伙伴合作在上面开发协作过程：多人协作时，大家都会往master和dev分支上推送各自的修改第一步：git clone http地址/ssl地址值得注意的是从远程克隆时，默认情况下，你的小伙伴只能看到本地的master分支第二步：当你的小伙伴需要在dev分支上进行开发时，就必须创建远程origin的dev分支到本地使用如下命令git checkout -b dev origin/dev第三步：现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程具体使用如下命令123git add &lt;file&gt;git commit -m &quot;add env&quot;git push origin dev 第四步：如果推送失败说明远程分支比你的本地分支更新，需要先用git pull试图合并如果git pull失败并提示no tracking information说明本地分支和远程分支的链接关系没有建立,使用如下命令git branch --set-upstream-to=origin/dev dev如果git pull成功合并但是有冲突，那么先解决冲突，并在本地提交第五步：没有冲突或者解决冲突后，再用git push origin &lt;branch-name&gt; git rebase用法解释12git checkout devgit rebase origin dev 这些命令会把dev分支里的每一个提交都取消掉，并且把它们临时保存为补丁（patch）这些补丁放到（”.git/rebase”目录中），然后把本地的dev分支更新到origin/dev分支上，最后把保存的这些补丁应用到本地的dev分支上 当dev分支更新后，他会指向这些新创建的提交，而那些老的提交会被丢弃。如果运行垃圾回收机制，这些被丢弃的提交就会被删除掉 rebase过程中可能会出现冲突，这种情况下，git会停止rebase并让你区解决冲突，解决晚冲突后执行以下命令即可 12git add &lt;file&gt;git rebase --continue 在任何时候可以用--abort来终止rebase的操作，并且dev分支会回到rebase开始前的状态 rebase操作可以把本地未push的分叉提交历史整理成直线 rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比适用范围： 只对尚未推送或者分享给别人的本地修改执行变基操作 不对已推送至别处的提交执行变基操作标签管理发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样就唯一确定了打标签时刻的版本，将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以标签也是版本库的一个快照tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起创建标签 使用如下命令就可创建标签git tag v1.0默认是HEAD,也可以指定一个commit_id如下例git tag v1.0 f52c653 可以用命令查看所有标签git tag 注意标签不是按时间顺序列出，而是按字母排序的使用如下命令查看标签信息git show &lt;tagname&gt; 创建带有说明的标签，用-a指定标签名，-m指定说明文字如下例子git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb操作标签 删除本地标签git tag -d &lt;tagname&gt; 删除远程标签分两步：先从本地删除，然后再从远程删除命令如下12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 推送某个标签到远程使用如下命令git push origin &lt;tagname&gt; 一次性推送所有标签到远程git push origin --tags使用Github如何参与一个开源项目？以人气极高的bootstrap项目为例第一步：首先在github中搜索bootstrap或者访它的主页bootstrap主点击fork按钮就在自己的账号下克隆了一个bootstrap仓库第二步：从自己的账号下克隆刚才fork的仓库（注意一定要在自己的账号下克隆自己的仓库，这样你才能推送，如果从bootstrap的作者的仓库地址克隆（git clone http地址或ssl地址），因为你没有读写权限，你将不能推送修改第三步你在自己克隆的本地仓库中新建一个功能分支，然后进行相关文件的修改和添加，干完后往自己的仓库进行推送第四步如果你想推送你的修改到官方仓库，你可以在你刚才fork到自己账号下的bootstrap仓库中pull request具体步骤为点击New Pull Request，用自己的Github账号创建一个Pull Request，你自己的仓库会被默认设置为源仓库（head fork），询问你指定源分支（compare）、目标仓库（base fork）和目标分支（base）第五步等待官方审查pull request看它是否接受小结 在Github上，可以任意Fork开源仓库 自己拥有Fork后的仓库的读写权限 可以推送pull request给官方来贡献代码]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Git]]></title>
    <url>%2F2018%2F11%2F11%2FlearnGit%2F</url>
    <content type="text"><![CDATA[特别注意本文章主要适合初学者对git一个初步了解，里面的内容不是特别完善和正确 前言（两个问题）1.什么是版本控制？我为什么要关心它呢？版本控制是记录一个或者若干个文件内容变化，以便将来查阅特定版本修订状况的系统。我们不仅可以对软件源代码的文本文件制作版本管理，我们还可以对任何类型的文件进行版本控制 2.采用版本控制有什么好处？ 有了它你可以将某个文件回溯到之前的状态，甚至将整个项目都回退过去某个时间点的状态。 你可以比较文件的变化细节，查出最后是谁修改了那个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能的缺陷 使用版本控制系统还意味着即使你把整个项目中的文件改的改删的删，你也可以照样轻松恢复到原先的样子，但是额外增加的工作量却是微乎其微github的名字源于Git，Git是一个分布式版本控制系统，让程序员团队能够协作开发项目，git帮助大家管理为项目所作的工作，避免一个人的修改影响其他人所做的修改。你在项目中实现一个新功能的时候，git将跟踪你对每个文件所作的修改，而git将记录项目，如果你犯了错，想撤销所做的修改，可以轻松的返回以前的任何可行状态：代码，项目参与者的信息，问题和bug报告等 正文1.配置Git跟踪谁修改了项目，哪怕参与项目的只有一个人，所以，Git需要知道你的用户名和电子邮件，你必须提供用户名，但可以使用虚构的电子邮件地址12git config --global user.name &quot;username&quot;git config --global user.email &quot;username@example.com&quot; 注意git config命令的–global参数，用了这个参数，表示你对这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定不同的用户名和Email地址 2.创建项目 我们来创建一个要进行版本控制的项目（又称版本库）。在你的系统创建一个名为learngit的文件夹使用如下命令mkdir learngit //创建文件learngitcd learngit //进入learngit文件夹里面dir //显示learngit存在目录 我们进入一个文件管理系统，进入learngit文件夹中创建一个hello-world.html文件在里面写上console.log(‘Hello World’) //注意html5的格式还是要有的3.初始化仓库使用以下命令创建一个git仓库git init然后会出现提示信息提示你创建了一个空的git仓库4.进行其他操作前先检查下状态使用如下命令12345678910git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be commited) hello_world.html nothing added to commit but untracked files present (use &quot;git add&quot; to track) 在git中分支是项目的一个版本，从这里的输出我们可以知道，我们位于分支的master 我们每次查看项目的时候，输出都是我们位于分支master上，接下来的输出表明，我将进行项目的提交，提交时项目在特定时间的快照 Git指出了项目中未被跟踪的文件，因为我们还没有告诉他要跟踪那些文件，接下来我们被告知没有任何东西添加到当前提交里面，我们需要将要跟踪的文件加入到仓库 5.将文件加入到仓库1234567891011git add ./learngit(master)git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;) new file: hello-world.html git add . 将项目中未被跟踪的文件都加入到仓库中，它不提交这些文件，而是让git开始关注他们。现在我们检查这个项目的状态，发现Git找到了需要提交的文件的一些修改，标签new file 表示这些文件是新加入的 6.执行提交1234git commit -m &quot;Started project&quot;[master(root-commit) 5d6cecal] Started project 1 file changed, 1 insertion(+) create mode 1006444 hello-world.html 我们在执行git commit -m &quot;Started project&quot; 的时候，是拍摄项目快照 -m是让Git接下来的消息记录到项目的历史纪录中，输出表明我们在分支master上，而且有一个文件被修改了 -m后面输入的内容是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就从历史记录中方便地找到改动记录 7.查看提交历史1234567git logcommit 5dcfhfhfhhfhfhfhfhhffhhfhfhhfhfhfhfh(HEAD -&gt; master)Author: username&lt;xxxxx.example.com&gt;Date: Sat Dec 9 20:16:17 2017 +0800 Started project ‘git log’是git日志的意思我们每次提交的时候，Git都会生成一个包好40字符的独一无二的引用ID，它记录提交是谁执行的，提交时间，以及提交的指定消息，但是不是任何情况下都需要所有这些信息，因此git提供一个选项，让我们能够打印提交历史条目的更简单版本log --pretty12fhhfhfhfhhfhd34hfhfh676hfrhffh(HEAD -&gt; master) Started project 标志 –pretty=oneline（指定显示一项重要的内容（提交的引用ID以及为提交记录的消息）） 8.第二次提交 为了显示版本控制的强大，我们需要对项目进行修改，并提交所做的修改，为此，我们在文件中再添加一行代码 12console.log(&apos;Hello World&apos;)console.log(&quot;Hello git&quot;) 如果我们查看项目的状态，将发现Git注意到了这个文件的变化1234567git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be commited) (use &quot;git checkout--&lt;file&gt;...&quot; to discared changes in working directory) modified : hello-world.htmlNo changes added on commit (use &quot;git add&quot;and/or &quot;git commit -a&quot;) 这个指出了我们当前所在的分支为master，其中做出修改的文件是hello-world.html,而且所做的修改还没有提交接下来我们提交所做的修改，并且查看操作 提交 123git commit -am &quot;Extrending greeting&quot;[master b4ee15d] Extrended greeting. 1 file changed, 2 insertion(+), 1 deletiong(-) 查看状态 123git statusOn branch masternothing to commit,working tree clen 查看提交历史中重要信息 1234git log --pretty=onelingb4ee15dfhfhfhfhfhfhhfhfhfhfhfhhfhhfhfhfhfhfhryrytyfhfh(HEAD -&gt; master) Extrending greeting5d6cecafhfheyedfdjafoefhoehvfhefheofheofhcncnahffhdefh Started project 上面的解释是：我们执行提交，并且执行git commit的时候制定了标志-am其中-a是让Git将仓库中所有修改了的文件都加入当前提交中（如果我们两次提交之间加入了新文件，我们执行git add .操作，将新文件加入到仓库中）标志-m让Git在提交历史中记录一条消息 9.撤销更改 git checkout .放弃最后一次提交对这个文件所做所有操作，将项目恢复到最后一次提交的状态 git checkout 引用ID的前6个字符` 放弃最近所做的工作，回到指定的以前的提交]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[settingBlog]]></title>
    <url>%2F2018%2F11%2F09%2FsettingBlog%2F</url>
    <content type="text"><![CDATA[前言以前看到有人搭建自己的博客，觉得自己有机会一定要试试，至于搭建博客的原因，自己搭建博客的话，样式的选择比较自由，可以自己选择，不受限于各大平台，另外我也想把这个自己搭建的平台当成自己记录笔记的一个方式，平时自己学习的东西可以通过这个平台方便以后记忆，同时有时候你也可以分享给别人自己的一些学习成果 目录 搭建环境准备（包括node.js和git环境，github账户的设置） 安装Hexo 配置Hexo 选择主题 怎样将Hexo与github page联系起来 怎样发布文章1.搭建环境准备 首先安装你的电脑必须安装node.js（最好全局安装方便以后使用） 安装完成后打开cmd命令面板使用以下命令12node -vnpm -v 如果可以看到版本号说明安装成功 进入git官网安装git，安装的时候看下图处于安全考虑，只有在git Bash中才能进行git的相关操作。安装上图进行选择，将会使得git安装程序在系统PATH中加入git的相关路径，使得你可以在cmd界面下调用git，不用打开git Bash安装完成后在cmd中输入git --version如果可以看到版本号说明安装成功，如果不正确则要回头检查自己的安装过程2.安装Hexo在自己认为合适的地方创建一个文件夹，这里以我自己D/Hexo为例子，在D盘目录下创建一个Hexo文件夹，并在命令行窗口进入到该目录在命令行中输入npm install hexo-cli -g然后使用如下命令安装npm install hexo --save安装完成后在命令行中输入hexo -v如果可以看到hexo的版本号说明安装成功3.配置Hexo初始化你的项目输入hexo init yourproject我的是myproject然后输入以下命令安装依赖npm install首次体验Hexo继续操作在命令行中输入hexo g然后输入hexo s在浏览器打开http://localhost:4000，你将会看到一个hexo页面，如果看到说明成功配置Hexo4.选择主题 在站点根目录输入（我的是D://hexo/myproject)git clone https://github.com/iissnan/hexo-theme-next themes/next 完成后，打开站点配置文件，找到theme字段，并将其值更改为next 配置文件就是根目录下的_config.yml文件theme: next 在终端输入123hexo clean //清除缓存hexo g //重新生成代码hexo s //部署到本地 然后打开浏览器访问localhost:4000查看效果next主题有三种选择，这个只是最简洁的一种，我们选择最好看的那个 Muse-默认scheme，这是next最初的版本，黑白主调，大量留白Mist-Muse的紧凑版本，整洁有序的单栏外观Pisces-双栏的scheme，小家碧玉的清新 配置NexT在站点根目录/themes/next/_config.yml 文件中修改scheme: Pisces然后123hexo clean //清除缓存hexo g //重新生成代码hexo s //部署到本地 当然，你完全可以进行很多的自定义设置甚至修改源码，定制自己的主题，跟多的设置请移步官方文档https://theme-next.iissnan.com/getting-started.html 5.将Hexo与github page联系起来首先你先要在github官网注册一个账号，然后创建一个仓库具体如何创建可以百度相关教程布置完成仓库后你可以得到一个链接，访问这个链接，你可以得到一个页面，如果看到了这个页面说明成功了 6.发布文章使用如下命令首先hexo new post &#39;titile&#39;这是在source中新建一个_post文件夹你可以在D://hexo/myproject/source中看到先做个清理防止配置接下来是Hexo生成hexo g然后是Hexo部署(你先要安装一个插件使用npm install hexo-deployer-git --save)你的所有安装的插件都可以在pack.json中看到hexo d当然你也可以写到一起hexo d -ghexo g -d两者的效果是一样的然后使用hexo s最后使用github中的你得到的链接访问看看效果]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[insertImage]]></title>
    <url>%2F2018%2F11%2F08%2FinsertImage%2F</url>
    <content type="text"><![CDATA[向文章中添加图片使用官方的方式我觉的太麻烦，所以查找资料并结合本人的实践找到了以下的方法 首先修改站点配置文件_config.yml中的post_asset_folder（随后你生成的draft或post都会附带一个与文章同名的目录）图片放在这个目录中就可以了post_asset_folder: true 在hexo你的项目目录下（我的是myproject）执行npm install asset-image –save,这是下载安装一个上传本地图片的插件 稍等片刻hexo new post “title”生成md博文时，/source/_post文件夹里除了有:year/:month/:day:/title.md文件还有一个同名的文件夹 ![这里输入图片描述](图片名.jpg)下面来张傻狗图片镇楼]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2018%2F11%2F05%2Farticle-title%2F</url>
    <content type="text"><![CDATA[序言：写一篇博客关于markdown的基本语法，方便现在学习和以后复习 起因：现在的前端基本都用上了前端构建工具，那就难免要写一些readme等等的说明性文件这样编写的文件一般都是.md文件，编写的语法自然跟其他格式的文件有所区别本文是markdown文件的一个笔记，仅供学习和参考 正文： 标题的几种写法第一种：一级标题写法二级标题写法三级标题写法四级标题写法五级标题写法六级标题写法####### 七级标题写法前面带#号，后面带文字，分别表示h1-h6，上面可以看出，直到h6,而且h1下面会有一条横线，注意： #号后面有空格第二种：这是一级标题这是二级标题 这种方式只能表示一级和二级标题，而且=和-的数量好像没有限制，只要大于一个就行第三种： 一级标题二级标题这种方式也可以表示h1-h6标题 列表的几种写法我们都知道列表分为有序列表和无需列表，下面我们直接展示2种列表的写法无序列表 1 2 3 1 2 3 1 1 1有序列表 list1 list2 list3有序列表就相对简单一点，只有一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的序号根据第一行列表的数字顺序来的，比如说：有序列表 list1 list2 list3 区块引用普通引用 不以结婚为目的的恋爱都是耍流氓 这是毛主席说的 前方高能 注意：这里是为了提醒有刺激的事情即将发生，请做好准备 引用的用法就是在语句前面加一个&gt;,注意是英文的那个右尖括号，注意空格引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看下方实例 名人名言 不以结婚为目的都是耍流氓 ——毛主席 高举中国特色社会主义伟大旗帜 ——习大大 上面的代码全部加上引用标签就变成了一个大的引用，引用里面还有引用 嵌套引用 一级引用 二级引用 三级引用 四级引用 五级引用 六级引用 七级引用 上面可以看出，想要在上一次引用中嵌套一层引用，只需要多加一个&gt;,理论上可以无限嵌套，注意：多层嵌套&gt;是不需要连续在一起，只要在一行就可以了，中间允许空格，但是为了好看，还是需要把排版搞好 华丽的分割线 分隔线可以由* - _(星号，减号，下划线)这3个符号的至少3个符号表示，注意至少要3个，且需要连续，有空格也可以 链接支持两种链接方式：行内式和参数式，不管是哪一种，链接文字都是用[方括号]来标记行内式NexT使用文档列表链接 列表1 列表2参数式 这里是参数1name,这里是参数2home实际上就是把链接当作参数，适合多次使用链接的场景 图片图片也有两种方式，行内式和参数式 图片引用图片11.行内式 博客园参数式图片，这里是 ![博客园]用法跟链接基本一样，唯一不同的是，图片前面要写上一个！ 代码框单行代码&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;多行代码123&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;门前大树下&lt;/a&gt;&lt;/p&gt; 表格 name age sex Tony 20 男 Lucy 18 女 表头1 表头2 content cell content cell content cell content cell 学号 姓名 分数 小明 男 75 小红 女 64 小虎 男 34 上面有三种方式用来写表格，表格的格式不一定要对齐，但是为了好看对齐是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，但是缺点是表格外面没有边框包起来 强调强调字体倾斜字体倾斜字体加粗字体加粗一个*号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗10.转义转义 \ ` ~ _ - + . !md文件的转义，基本跟js转义是一样的 删除线删除线请删除我吧]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[给Hexo Next设置阅读全文]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[前言：最近使用Hexo搭建了自己的博客，并且使用了简洁但是强大的NexT主题。这里介绍一下NexT主题下设置在首页显示一篇文章的简介，在简介后面提供一个链接阅读全文来进入文章的详情页 正文： 在文章中使用&lt; !–more–&gt; 手动进行截断这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。 在文章中的front-matter中添加description，并提供文章摘录这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。 自动形成摘要，在主题配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定 123auto_excerpt: enable: false length: 150]]></content>
      <categories>
        <category>studyDiary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
